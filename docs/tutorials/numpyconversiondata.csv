numpy_command,mlx_equivalent,parameter_differences,notes
"np.array([1, 2, 3])","mx.array([1, 2, 3])",None,"Similar usage"
"np.zeros((3, 3))","mx.zeros((3, 3))",None,"Similar usage"
"np.ones((3, 3))","mx.ones((3, 3))",None,"Similar usage"
"np.eye(3)","mx.eye(3)",None,"Similar usage"
"np.arange(10)","mx.arange(10)",None,"Similar usage"
"np.linspace(0, 1, 10)","mx.linspace(0, 1, 10)",None,"Similar usage"
"np.random.normal(0, 1, (3, 3))","mx.random.normal(0, 1, (3, 3))",None,"Similar usage"
"np.random.uniform(0, 1, (3, 3))","mx.random.uniform(0, 1, (3, 3))",None,"Similar usage"
"a[0, 1]","a[0, 1]",None,"Basic indexing is similar"
"a[1:3, 2:4]","a[1:3, 2:4]",None,"Basic slicing is similar"
"np.take(a, indices, axis=0)","mx.take(a, indices, axis=0)",None,"Similar usage"
"None","mx.slice(a, start_indices, axes, slice_size)","MLX-specific: start_indices must be MLX array, axes and slice_size must be Python lists/tuples","No direct NumPy equivalent"
"None","mx.slice_update(a, update, start_indices, axes)","MLX-specific: update and start_indices must be MLX arrays, axes must be Python list/tuple","No direct NumPy equivalent"
"a + b","mx.add(a, b)",None,"MLX prefers function calls over operators"
"a - b","mx.subtract(a, b)",None,"MLX prefers function calls over operators"
"a * b","mx.multiply(a, b)",None,"MLX prefers function calls over operators"
"a / b","mx.divide(a, b)",None,"MLX prefers function calls over operators"
"a @ b or np.matmul(a, b)","mx.matmul(a, b)",None,"Similar usage"
"np.dot(a, b)","mx.matmul(a, b)",None,"Use matmul in MLX"
"np.exp(a)","mx.exp(a)",None,"Similar usage"
"np.log(a)","mx.log(a)",None,"Similar usage"
"np.sin(a)","mx.sin(a)",None,"Similar usage"
"np.cos(a)","mx.cos(a)",None,"Similar usage"
"np.tan(a)","mx.tan(a)",None,"Similar usage"
"np.tanh(a)","mx.tanh(a)",None,"Similar usage"
"np.sum(a, axis=0)","mx.sum(a, axis=0)",None,"Similar usage"
"np.max(a, axis=0)","mx.max(a, axis=0)",None,"Similar usage"
"np.min(a, axis=0)","mx.min(a, axis=0)",None,"Similar usage"
"np.mean(a, axis=0)","mx.mean(a, axis=0)",None,"Similar usage"
"np.var(a, axis=0)","mx.var(a, axis=0)",None,"Similar usage"
"np.std(a, axis=0)","mx.std(a, axis=0)",None,"Similar usage"
"np.reshape(a, (2, 3))","mx.reshape(a, (2, 3))",None,"Similar usage"
"np.transpose(a)","mx.transpose(a)",None,"Similar usage"
"np.concatenate([a, b], axis=0)","mx.concatenate([a, b], axis=0)",None,"Similar usage"
"np.stack([a, b], axis=0)","mx.stack([a, b], axis=0)",None,"Similar usage"
"np.split(a, 3, axis=0)","mx.split(a, 3, axis=0)",None,"Similar usage"
"np.where(condition, x, y)","mx.where(condition, x, y)",None,"Similar usage"
"np.argmax(a, axis=0)","mx.argmax(a, axis=0)",None,"Similar usage"
"np.argmin(a, axis=0)","mx.argmin(a, axis=0)",None,"Similar usage"
"np.clip(a, min_val, max_val)","mx.clip(a, min_val, max_val)",None,"Similar usage"
"np.abs(a)","mx.abs(a)",None,"Similar usage"
"np.sqrt(a)","mx.sqrt(a)",None,"Similar usage"
"np.power(a, 2)","mx.power(a, 2)",None,"Similar usage"
"np.square(a)","mx.square(a)",None,"Similar usage"
"np.sign(a)","mx.sign(a)",None,"Similar usage"
"np.round(a)","mx.round(a)",None,"Similar usage"
"np.ceil(a)","mx.ceil(a)",None,"Similar usage"
"np.floor(a)","mx.floor(a)",None,"Similar usage"
"np.isnan(a)","mx.isnan(a)",None,"Similar usage"
"np.isinf(a)","mx.isinf(a)",None,"Similar usage"
"np.logical_and(a, b)","mx.logical_and(a, b)",None,"Similar usage"
"np.logical_or(a, b)","mx.logical_or(a, b)",None,"Similar usage"
"np.logical_not(a)","mx.logical_not(a)",None,"Similar usage"
"np.equal(a, b)","mx.equal(a, b)",None,"Similar usage"
"np.not_equal(a, b)","mx.not_equal(a, b)",None,"Similar usage"
"np.greater(a, b)","mx.greater(a, b)",None,"Similar usage"
"np.greater_equal(a, b)","mx.greater_equal(a, b)",None,"Similar usage"
"np.less(a, b)","mx.less(a, b)",None,"Similar usage"
"np.less_equal(a, b)","mx.less_equal(a, b)",None,"Similar usage"
"np.pad(a, pad_width)","mx.pad(a, pad_width, mode='constant')",None,"Similar usage"
"np.tile(a, reps)","mx.tile(a, reps)",None,"Similar usage"
"np.repeat(a, repeats, axis)","mx.repeat(a, repeats, axis)",None,"Similar usage"
"np.expand_dims(a, axis)","mx.expand_dims(a, axis)",None,"Similar usage"
"np.squeeze(a, axis)","mx.squeeze(a, axis)",None,"Similar usage"
"np.diag(a)","mx.diag(a)",None,"Similar usage"
"np.triu(a)","mx.triu(a)",None,"Similar usage"
"np.tril(a)","mx.tril(a)",None,"Similar usage"
"np.einsum('ij,jk->ik', a, b)","mx.einsum('ij,jk->ik', a, b)",None,"Similar usage"
"np.linalg.norm(a)","mx.linalg.norm(a)",None,"Similar usage"
"np.linalg.inv(a)","mx.linalg.inv(a)",None,"Similar usage"
"np.linalg.solve(a, b)","mx.linalg.solve(a, b)",None,"Similar usage"
"np.linalg.svd(a)","mx.linalg.svd(a)",None,"Similar usage"
"np.linalg.eig(a)","mx.linalg.eig(a)",None,"Similar usage"
"np.linalg.eigvals(a)","mx.linalg.eigvals(a)",None,"Similar usage"
"np.linalg.qr(a)","mx.linalg.qr(a)",None,"Similar usage"
"np.linalg.cholesky(a)","mx.linalg.cholesky(a)",None,"Similar usage"
"np.fft.fft(a)","mx.fft.fft(a)",None,"Similar usage"
"np.fft.ifft(a)","mx.fft.ifft(a)",None,"Similar usage"
"np.fft.fft2(a)","mx.fft.fft2(a)",None,"Similar usage"
"np.fft.ifft2(a)","mx.fft.ifft2(a)",None,"Similar usage"
"float(a)","None","Never use Python type conversions on MLX arrays","Use mx.array(a).item() if absolutely necessary"
"int(a)","None","Never use Python type conversions on MLX arrays","Use mx.array(a).item() if absolutely necessary"
"a.astype(np.float32)","mx.cast(a, mx.float32)",None,"Use mx.cast with MLX dtype constants"
"a.reshape(-1)","mx.reshape(a, -1)",None,"Similar usage"
"a.T","mx.transpose(a)",None,"Use transpose function instead of .T property"
"a.copy()","mx.array(a)",None,"Create a new array with the same data"
"a.flatten()","mx.reshape(a, -1)",None,"Use reshape instead of flatten"
"np.save('file.npy', a)","mx.save('file.npy', a)",None,"Similar usage"
"np.load('file.npy')","mx.load('file.npy')",None,"Similar usage"

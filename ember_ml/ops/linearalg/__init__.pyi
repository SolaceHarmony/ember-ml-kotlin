"""
Type stub file for ember_ml.ops.linearalg module.

This provides explicit type hints for linear algebra operations,
allowing type checkers to recognize them properly.
"""

from typing import List, Optional, Any, Union, Tuple, Literal

from ember_ml.backend.mlx.types import TensorLike
type Tensor = Any

# Matrix decomposition functions
def svd(a: TensorLike, full_matrices: bool = ..., compute_uv: bool = ...) -> Union[Tensor, Tuple[Tensor, Tensor, Tensor]]: ...
def qr(a: TensorLike, mode: Literal["reduced", "complete", "r", "raw"] = ...) -> Union[Tensor, Tuple[Tensor, Tensor]]: ...
def eig(a: TensorLike) -> Tuple[Tensor, Tensor]: ...
def eigvals(a: TensorLike) -> Tensor: ...
def cholesky(a: TensorLike) -> Tensor: ...

# Matrix operations
def inv(a: TensorLike) -> Tensor: ...
def pinv(a: TensorLike) -> Tensor: ...
def solve(a: TensorLike, b: TensorLike) -> Tensor: ...
def matrix_norm(a: TensorLike, ord: Optional[Union[int, str]] = ..., axis: Optional[Tuple[int, int]] = ..., keepdims: bool = ...) -> Tensor: ...
def matrix_rank(a: TensorLike, tol: Optional[float] = ...) -> Tensor: ...
def det(a: TensorLike) -> Tensor: ...
def slogdet(a: TensorLike) -> Tuple[Tensor, Tensor]: ...
def trace(a: TensorLike) -> Tensor: ...

# Vector operations
def norm(x: TensorLike, ord: Optional[Union[int, float, str]] = ..., axis: Optional[Union[int, Tuple[int, ...]]] = ..., keepdims: bool = ...) -> Tensor: ...
def cross(a: TensorLike, b: TensorLike, axis: int = ...) -> Tensor: ...
def outer(a: TensorLike, b: TensorLike) -> Tensor: ...
def inner(a: TensorLike, b: TensorLike) -> Tensor: ...

# Eigenvalue problems
def eigvalsh(a: TensorLike, UPLO: str = ...) -> Tensor: ...
def eigh(a: TensorLike, UPLO: str = ...) -> Tuple[Tensor, Tensor]: ...

# Matrix products
def kron(a: TensorLike, b: TensorLike) -> Tensor: ...
def kronecker_product(a: TensorLike, b: TensorLike) -> Tensor: ...
def multi_dot(arrays: List[TensorLike]) -> Tensor: ...

# High-Precision Computing (HPC) operations
class HPC16x8:
    """High-precision computing using limb-based arithmetic."""
    
    def __init__(self, high: TensorLike, low: Optional[TensorLike] = None): ...
    
    @classmethod
    def from_array(cls, arr: TensorLike) -> 'HPC16x8': ...
    
    def to_float32(self) -> Tensor: ...
    
    def complete_basis(self) -> 'HPC16x8': ...
    
    def qr(self) -> Tuple[Tensor, Tensor]: ...
    
    def eig(self) -> Tuple[Tensor, Tensor]: ...
    
    def add(self, other: 'HPC16x8') -> 'HPC16x8': ...
    
    def subtract(self, other: 'HPC16x8') -> 'HPC16x8': ...
    
    def multiply(self, other: 'HPC16x8') -> 'HPC16x8': ...